import { Injectable, NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { Subject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const diractionMap = { left: 'left', right: 'left', top: 'top', bottom: 'top' };
/** @type {?} */
const multyMap = { left: 1, right: -1, top: 1, bottom: -1 };
/**
 * @record
 */
function AnimationOption() { }
if (false) {
    /** @type {?|undefined} */
    AnimationOption.prototype.keyframes;
    /** @type {?} */
    AnimationOption.prototype.keyframeAnimationOptions;
}
/**
 * @record
 */
function MatDialogConfig() { }
if (false) {
    /** @type {?|undefined} */
    MatDialogConfig.prototype.title;
    /** @type {?|undefined} */
    MatDialogConfig.prototype.animation;
    /** @type {?|undefined} */
    MatDialogConfig.prototype.position;
}
class NgDialogAnimationService {
    /**
     * @param {?} dialog
     * @param {?} ngZone
     * @param {?=} incomingOptions
     * @param {?=} outgoingOptions
     */
    constructor(dialog, ngZone, incomingOptions, outgoingOptions) {
        this.dialog = dialog;
        this.ngZone = ngZone;
        this.incomingOptions = incomingOptions;
        this.outgoingOptions = outgoingOptions;
    }
    /**
     * @template T, D, R
     * @param {?} componentOrTemplateRef
     * @param {?=} config
     * @return {?}
     */
    open(componentOrTemplateRef, config) {
        /** @type {?} */
        const dir = config.direction || (document.querySelectorAll('[dir="rtl"]').length ? 'rtl' : 'ltr');
        config.direction = config.direction || dir;
        if (config.animation) {
            if (config.animation.to === 'aside') {
                config.animation.to = dir === 'rtl' ? 'left' : 'right';
            }
        }
        if (config.position && config.position.rowEnd) {
            if (dir === 'rtl') {
                config.position.right = config.position.rowEnd;
            }
            else {
                config.position.left = config.position.rowEnd;
            }
        }
        if (config.position && config.position.rowStart) {
            if (dir === 'rtl') {
                config.position.left = config.position.rowStart;
            }
            else {
                config.position.right = config.position.rowStart;
            }
        }
        /** @type {?} */
        const ref = this.dialog.open(componentOrTemplateRef, config);
        /** @type {?} */
        const container = (/** @type {?} */ (document.getElementsByTagName('mat-dialog-container')[0]));
        if (config.title) {
            /** @type {?} */
            const el = document.createElement('span');
            el.textContent = config.title;
            el.className = 'dialogTitle';
            /** @type {?} */
            const elClose = document.createElement('span');
            elClose.textContent = 'X';
            elClose.className = 'dialogClose';
            elClose.addEventListener('click', (/**
             * @return {?}
             */
            () => {
                ref.close();
            }));
            /** @type {?} */
            const titleContainer = document.createElement('div');
            titleContainer.className = 'titleContainer';
            titleContainer.append(el);
            titleContainer.append(elClose);
            container.prepend(titleContainer);
        }
        if (config.animation) {
            /** @type {?} */
            const incomingOptions = config.animation.incomingOptions ||
                this.incomingOptions || { keyframeAnimationOptions: { duration: 600, easing: 'ease-in' } };
            /** @type {?} */
            const outgoingOptions = config.animation.outgoingOptions ||
                this.outgoingOptions || { keyframeAnimationOptions: { duration: 600, easing: 'ease-out' } };
            /** @type {?} */
            const wrapper = document.getElementsByClassName('cdk-global-overlay-wrapper')[0];
            /** @type {?} */
            const animate = (/**
             * @param {?} keyframes
             * @param {?} options
             * @return {?}
             */
            (keyframes, options) => {
                return wrapper.animate(keyframes, options);
            });
            /** @type {?} */
            const _afterClosed = new Subject();
            ref.afterClosed = (/**
             * @return {?}
             */
            () => {
                return _afterClosed.asObservable();
            });
            /** @type {?} */
            const closeFunction = ref.close;
            /** @type {?} */
            let incomeKeyFrames = incomingOptions.keyframes;
            /** @type {?} */
            let outgoingKeyFrames = outgoingOptions.keyframes;
            if (config.animation.to) {
                /** @type {?} */
                const to = diractionMap[config.animation.to];
                /** @type {?} */
                const keyFrame100 = {};
                /** @type {?} */
                const keyFrame0 = {};
                keyFrame0[to] = 0;
                keyFrame100[to] =
                    to === 'top' || to === 'bottom'
                        ? container.clientHeight * multyMap[config.animation.to] + 'px'
                        : container.clientWidth * multyMap[config.animation.to] + 'px';
                incomeKeyFrames = incomeKeyFrames || [keyFrame100, keyFrame0];
                outgoingKeyFrames = outgoingKeyFrames || [keyFrame0, keyFrame100];
            }
            animate(incomeKeyFrames, incomingOptions.keyframeAnimationOptions);
            /** @type {?} */
            const closeHandler = (/**
             * @param {?=} dialogResult
             * @return {?}
             */
            (dialogResult) => {
                _afterClosed.next(dialogResult);
                /** @type {?} */
                const animation = animate(outgoingKeyFrames, outgoingOptions.keyframeAnimationOptions);
                animation.onfinish = (/**
                 * @return {?}
                 */
                () => {
                    ((/** @type {?} */ (wrapper))).style.display = 'none';
                    this.ngZone.run((/**
                     * @return {?}
                     */
                    () => ref.close(dialogResult)));
                });
                ref.close = closeFunction;
            });
            ref.close = (/**
             * @param {?=} dialogResult
             * @return {?}
             */
            (dialogResult) => closeHandler(dialogResult));
        }
        return ref;
    }
}
NgDialogAnimationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
NgDialogAnimationService.ctorParameters = () => [
    { type: MatDialog },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ['INCOMING_OPTION',] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ['OUTGOING_OPTION',] }] }
];
/** @nocollapse */ NgDialogAnimationService.ɵprov = ɵɵdefineInjectable({ factory: function NgDialogAnimationService_Factory() { return new NgDialogAnimationService(ɵɵinject(MatDialog), ɵɵinject(NgZone), ɵɵinject("INCOMING_OPTION", 8), ɵɵinject("OUTGOING_OPTION", 8)); }, token: NgDialogAnimationService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgDialogAnimationService.prototype.dialog;
    /**
     * @type {?}
     * @private
     */
    NgDialogAnimationService.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    NgDialogAnimationService.prototype.incomingOptions;
    /**
     * @type {?}
     * @private
     */
    NgDialogAnimationService.prototype.outgoingOptions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgDialogAnimationService };
//# sourceMappingURL=ng-dialog-animation.js.map
